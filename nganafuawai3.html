<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Bidirectional Script Swapper</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {
  background: #111;
  color: #ffe600;
  font-family: 'Segoe UI', 'Arial', sans-serif;
  margin: 0;
  padding: 1rem;
}
h1 {
  font-size: 1.4rem;
  margin: .2em 0 .6em;
  text-align: center;
  color: #ffe600;
  text-shadow: 0 0 8px #ffe600, 0 0 16px #39ff14;
}
label {
  font-weight: bold;
  display: block;
  margin: .5em 0 .2em;
}
textarea {
  width: 100%;
  box-sizing: border-box;
  font: 1rem/1.35 monospace;
  min-height: 8rem;
  padding: .5rem;
  background: #222;
  color: #ffe600;
  border: 1.5px solid #39ff14;
  border-radius: 4px;
  box-shadow: 0 0 4px #39ff14;
}
#textB {
  background: #333;
}
button {
  padding: .4rem .9rem;
  font-size: 1rem;
  cursor: pointer;
  margin: .3rem .3rem 0 0;
  background: #111;
  color: #ffe600;
  border: 2px solid #39ff14;
  border-radius: 6px;
  box-shadow: 0 0 8px #39ff14, 0 0 2px #ffe600;
  font-weight: bold;
  transition: background 0.2s, color 0.2s, box-shadow 0.2s;
}
button:hover {
  background: #ffe600;
  color: #111;
  box-shadow: 0 0 16px #ffe600, 0 0 8px #39ff14;
}
.small {
  font-size: .82rem;
  color: #39ff14;
}
.grid {
  display: grid;
  gap: 1rem;
}
@media(min-width:700px) {
  .grid2 {
    grid-template-columns: 1fr 1fr;
  }
}
</style>
</head>
<body>

<h1>Bidirectional Script Swapper</h1>

<!-- === MAPPING BOXES === -->
<div class="grid grid2">
  <div>
    <label for="from">FROM list (one per line)</label>
    <textarea id="from" placeholder="a\nb\nc\nch\nng"></textarea>
  </div>
  <div>
    <label for="to">TO list (same number of lines)</label>
    <textarea id="to" placeholder="α\nβ\nγ\nч\nŋ"></textarea>
  </div>
</div>

<button id="build">Build mapping</button>
<button id="clearMap">Clear list</button>
<button id="exportMap">Export preset</button>
<button id="importMap">Import preset</button>
<input type="file" id="importFile" accept="application/json" style="display:none">
<label class="small"><input type="checkbox" id="ignoreCase"> Ignore case</label>
<label class="small"><input type="checkbox" id="wordMode"> Word mode (swap only whole words)</label>
<label class="small"><input type="checkbox" id="commaSplit"> Comma split mode (split by custom characters)</label>
<input type="text" id="splitChars" value="," style="width:6em;margin-left:.5em" placeholder="," title="Custom split characters">

<!-- === TEXT BOXES === -->
<div class="grid grid2" style="margin-top:1.4rem">
  <div>
    <label for="textA">Text A ⟶ (auto‑converts ➜ Text B)</label>
    <textarea id="textA" placeholder="Type or paste…"></textarea>
  </div>
  <div>
    <label for="textB">Text B ⟵ (auto‑converts ➜ Text A)</label>
    <textarea id="textB" placeholder="Type or paste…"></textarea>
  </div>
</div>

<script>
(() => {
  const $ = id => document.getElementById(id);

  // Elements
  const fromEl=$('from'), toEl=$('to'), buildBtn=$('build'), clearBtn=$('clearMap');
  const exportBtn=$('exportMap'), importBtn=$('importMap'), fileEl=$('importFile');
  const textA=$('textA'), textB=$('textB'), ignoreCaseEl=$('ignoreCase');
  const wordModeEl=$('wordMode'), commaSplitEl=$('commaSplit'), splitCharsEl=$('splitChars');

  // Current mappings
  let forward=[], reverse=[];          // arrays of [key,val] sorted longest‑first
  let disableSync=false;               // guard to avoid event ping‑pong

  // Build mapping tables from lists
  function buildMapping() {
    let fLines = fromEl.value.split(/\r?\n/).map(s=>s.trim());
    let tLines = toEl.value.split(/\r?\n/).map(s=>s.trim());
    // Comma split mode: split by custom chars
    if (commaSplitEl.checked) {
      const splitChars = splitCharsEl.value || ',';
      const splitter = new RegExp(`[${splitChars.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')}]`);
      // For each line, split FROM by custom chars, but keep TO as is
      let f = [], t = [];
      for (let i = 0; i < fLines.length; i++) {
        const fromParts = fLines[i].split(splitter).map(s => s.trim()).filter(Boolean);
        const toVal = tLines[i] || '';
        // If TO is a single value, map all FROM parts to it
        for (const fp of fromParts) {
          f.push(fp);
          t.push(toVal);
        }
      }
      fLines = f;
      tLines = t;
    }
    // Defensive: ensure mapping lengths match
    const mapF={}, mapR={};
    const max = Math.max(fLines.length, tLines.length);
    for(let i=0;i<max;i++){
      const k=fLines[i]||'', v=tLines[i]||'';
      if(!k) continue;
      addPair(mapF, mapR, k, v);
    }
    forward = objToSortedPairs(mapF);
    reverse = objToSortedPairs(mapR);
    convertA(); convertB();
  }

  // Add pair plus optional case variants
  function addPair(mapF, mapR, k, v){
    mapF[k]=v;
    mapR[v]=k;
    if(ignoreCaseEl.checked){
      const ku=k.toUpperCase(), kl=k.toLowerCase();
      const vu=v.toUpperCase?.()??v, vl=v.toLowerCase?.()??v;
      if(!mapF[ku]){mapF[ku]=vu; mapR[vu]=ku;}
      if(!mapF[kl]){mapF[kl]=vl; mapR[vl]=kl;}
    }
  }

  // Return array sorted by longest key first
  function objToSortedPairs(obj){
    return Object.keys(obj)
      .sort((a,b)=>b.length-a.length)
      .map(k=>[k,obj[k]]);
  }

  // Convert helper (one direction)
  function convert(str, pairs){
    if(!pairs.length||!str) return str;
    if(wordModeEl.checked) {
      // Word mode: use regex to swap only whole words
      let result = str;
      for(const [k,v] of pairs){
        // Escape regex special chars in k
        const escaped = k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const re = new RegExp(`\\b${escaped}\\b`, ignoreCaseEl.checked ? 'gi' : 'g');
        result = result.replace(re, v);
      }
      return result;
    } else {
      // Normal mode: greedy left-to-right
      let out='', i=0;
      while(i<str.length){
        let matched=false;
        for(const [k,v] of pairs){
          if(str.startsWith(k,i)){
            out+=v; i+=k.length; matched=true; break;
          }
        }
        if(!matched){out+=str[i]; i++;}
      }
      return out;
    }
  }

  // Live converters
  function convertA(){
    if(disableSync) return;
    disableSync=true;
    textB.value = convert(textA.value, forward);
    disableSync=false;
  }
  function convertB(){
    if(disableSync) return;
    disableSync=true;
    textA.value = convert(textB.value, reverse);
    disableSync=false;
  }

  // === Event wiring ===
  buildBtn.addEventListener('click', buildMapping);
  clearBtn.addEventListener('click', ()=>{fromEl.value='';toEl.value='';buildMapping();});
  ignoreCaseEl.addEventListener('change', buildMapping);
  wordModeEl.addEventListener('change', buildMapping);
  commaSplitEl.addEventListener('change', buildMapping);
  splitCharsEl.addEventListener('input', buildMapping);

  textA.addEventListener('input', convertA);
  textB.addEventListener('input', convertB);

  // --- Export mapping ---
  exportBtn.addEventListener('click', ()=>{
    const preset = {
      from: fromEl.value,
      to:   toEl.value,
      ignoreCase: ignoreCaseEl.checked,
      ts: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(preset,null,2)],{type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download='swap‑preset.json'; a.click();
    URL.revokeObjectURL(url);
  });

  // --- Import mapping ---
  importBtn.addEventListener('click', ()=>fileEl.click());
  fileEl.addEventListener('change', e=>{
    const file=e.target.files[0]; if(!file) return;
    const r=new FileReader();
    r.onload=evt=>{
      try{
        const p=JSON.parse(evt.target.result);
        if('from'in p)fromEl.value=p.from;
        if('to'in p)toEl.value=p.to;
        ignoreCaseEl.checked=!!p.ignoreCase;
        buildMapping();
      }catch(err){alert('Invalid preset file');}
    };
    r.readAsText(file);
  });

  // Build default empty mapping on first load
  buildMapping();
})();
</script>
</body>
</html>
